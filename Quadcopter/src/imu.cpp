#include "imu.h"


flightStateShared_t flightStateShared;
positionShared_t positionShared;
rawPositionShared_t homeRawPosition;
rawPositionShared_t rawPositionShared;
homePosition_t homePosition;
//receivedCommandsShared_t receivedCommands;

void* imuHandler(void* arg)
 {
/*
    bidirectionnalHandler_t* bidirectionnalHandler;
    bidirectionnalHandler = (bidirectionnalHandler_t*)arg;

    handler_t* mainITMHandler;
    handler_t* imuITMHandler;

    mainITMHandler = bidirectionnalHandler->mainITMHandler;
    imuITMHandler = bidirectionnalHandler->componentITMHandler;
    */
    handler_t* mainITMHandler;
    mainITMHandler = (handler_t*)arg;

    // Initialization of shared variables :
    initialize_mutex(&flightStateShared.readWriteMutex);
    initialize_mutex(&rawPositionShared.readWriteMutex);
    initialize_mutex(&positionShared.readWriteMutex);
    initialize_mutex(&homePosition.readWriteMutex);
    initialize_mutex(&homeRawPosition.readWriteMutex);


    // Notifying main thread of init :
    message_t currentMessage;
    strcpy(currentMessage.message, "main_imu_info_init");
    currentMessage.priority = 20;
    sendMessage(mainITMHandler, currentMessage);

    // Initialization of some handler variables :
    double gpsAltitude=0;
    double altitude=0;

    int sampleCount = 0;
    int sampleRate = 0;
    uint64_t rateTimer;
    uint64_t displayTimer;
    uint64_t now;

    int transitionToUltrasonic = 0;
    int transitionToGPSMS5611 = 0;
    int firstTimeUltra =1;
    int firstTimeGPSMS5611=1;
    int averageCounter = 0;



    //  using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.

    RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

    RTIMU *imu = RTIMU::createIMU(settings);
    RTPressure *pressure = RTPressure::createPressure(settings);

    if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {

        printDebug("[e] No IMU found\n");
        strcpy(currentMessage.message ,"main_imu_info_initfailed");
        currentMessage.priority = 20;
        sendMessage(mainITMHandler, currentMessage);
        pthread_exit(NULL);

    }

    //  This is an opportunity to manually override any settings before the call IMUInit

    //  set up IMU

    imu->IMUInit();

    // this is a convenient place to change fusion parameters

    imu->setGyroEnable(true);
    imu->setAccelEnable(true);
    imu->setCompassEnable(true);

    //  set up pressure sensor

    if (pressure != NULL)
        pressure->pressureInit();

    //  set up for rate timer

    rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();

    // Waiting for GPS FIX :

    if (DEBUG)
    {
       receivedCommands.latitude = 1;
       receivedCommands.longitude = 1;
       receivedCommands.altitude = 1;
  }
    else
    {
      if (!waitForGPS())
      {
          printDebug("[e] Failed to obtain 3D fix from GPS after several attemps, killing IMU...");
          strcpy(currentMessage.message ,"main_imu_info_initfailed");
          currentMessage.priority = 20;
          sendMessage(mainITMHandler, currentMessage);
          pthread_exit(NULL);
      }
    }
    // Init IMU

    double air_MS5611_trust = AIR_MS5611_TRUST;
    double air_gps_trust = AIR_GPS_TRUST;

    // BMP085 init and first calculation :

    /*bmp085_i2c_Begin();
    if (DEBUG) {imuData.pressure = 10;} else { imuData.pressure = calculateBmpAlt();}
    */

    // Ultrasonic init :
    unsigned int ultrasonicAltitude=0;
    unsigned int ultrasonicAltitudeLastValue=0;

    // For now, turning ultrasonic ON on startup :
    strcpy(currentMessage.message ,"reader_imu_order_ultrasonicon");
    currentMessage.priority = 20;
    sendMessage(mainITMHandler, currentMessage);

    // Making home position :
//    makeHome(imuData.pressure);


    // Notify main thread of end of init :
    strcpy(currentMessage.message ,"main_imu_info_endofinit");
    currentMessage.priority = 20;
    sendMessage(mainITMHandler, currentMessage);

    // Entering handler loop Area :

    while(1)
    {
        // Sensor updating Area :

        // Updating IMU :
         //  poll at the rate recommended by the IMU

        usleep(imu->IMUGetPollInterval() * 1000);

        while (imu->IMURead()) {
            RTIMU_DATA imuData = imu->getIMUData();

            //  add the pressure data to the structure
            if (pressure != NULL)
                pressure->pressureRead(imuData);

            if(DISPLAY)
	    {

	    sampleCount++;

            now = RTMath::currentUSecsSinceEpoch();

            //  display 10 times per second
            if ((now - displayTimer) > 100000) {
                printf("Sample rate %d: %s\n", sampleRate, RTMath::displayDegrees("", imuData.fusionPose));

                if (pressure != NULL) {
                    printf("Pressure: %4.1f, height above sea level: %4.1f, temperature: %4.1f\n",
                           imuData.pressure, RTMath::convertPressureToHeight(imuData.pressure), imuData.temperature);
                }

                fflush(stdout);
                displayTimer = now;
            }

            //  update rate every second
            if ((now - rateTimer) > 1000000) {
                sampleRate = sampleCount;
                sampleCount = 0;
                rateTimer = now;
            }
	    }
        // Updating BMP :
        //if (DEBUG) {imuData.pressure = 10;} else {imuData.pressure = calculateBmpAlt();}

        // Altitude calculation Area :
        pthread_mutex_lock(&receivedCommands.readWriteMutex);

	if (DEBUG)
	{
		 ultrasonicAltitude = 10;
		 gpsAltitude = 10;
	}
	else
	{
        	ultrasonicAltitude = receivedCommands.ultrasonicTelemeter;
        	gpsAltitude = receivedCommands.altitude;
	}

        pthread_mutex_unlock(&receivedCommands.readWriteMutex);




        if (ultrasonicAltitude == -1) // We are far from ground
        {
            if ((!transitionToGPSMS5611) && firstTimeUltra)
            {
                transitionToGPSMS5611 = 1;
                transitionToUltrasonic = 0;
                firstTimeUltra = 0;
                firstTimeGPSMS5611 = 1;
            }

            if ( abs(imuData.pressure - gpsAltitude) / imuData.pressure >= MAX_ALT_DIFF )
            {
                printf("[e] Error in IMU : to high divergence between gps altitude and bmp altitude");
                // Switching altitude to pressure-only :
                air_MS5611_trust=100;
                air_gps_trust=0;
            }

            if (transitionToGPSMS5611)
            {
                altitude = (averageCounter*((air_MS5611_trust*imuData.pressure + air_gps_trust*gpsAltitude) / 100) + (NUMBER_OF_AVERAGE-averageCounter)*ultrasonicAltitudeLastValue);
                if (averageCounter <= NUMBER_OF_AVERAGE) averageCounter++;
                else transitionToGPSMS5611 = 0;
            }

            else altitude = (air_MS5611_trust*imuData.pressure + air_gps_trust*gpsAltitude) / 100;
        }

        else // We are close to ground
        {
            if ((!transitionToUltrasonic) && firstTimeGPSMS5611)
            {
                transitionToUltrasonic = 1;
                transitionToGPSMS5611 = 0;
                firstTimeGPSMS5611 = 0;
                firstTimeUltra = 1;
            }

            if (transitionToUltrasonic)
            {
                altitude = ((NUMBER_OF_AVERAGE - averageCounter)*((air_MS5611_trust*imuData.pressure + air_gps_trust*gpsAltitude) / 100) + (averageCounter)*ultrasonicAltitude);
                if (averageCounter <= NUMBER_OF_AVERAGE) averageCounter++;
                else transitionToUltrasonic = 0;
            }

        }




        /*if (receivedCommands.altitude<1 && imuData.pressure<1)//1m du sol???
        {
            altitude = (0,2*ultrasonicAltitude + 0.3*imuData.pressure +0.5*receivedCommands.altitude)/3;//filtre à complémentarité
             if (imuData.pressure>0.05 && imuData.pressure<0.5)// de 10 à 50 cm du sol ???
             {
                 altitude = (0,6*ultrasonicAltitude + 0.4*imuData.pressure)/2; // ou 0.4*receivedCommands.altitude : le capteur le  lus rapide et précis dans ces conditions
             }
        }

        else {altitude = (0.5*imuData.pressure + 0.5*receivedCommands.altitude)/2;}
*/



        // Position calculation Area :

        double x,y;
        double* px = &x;
        double* py = &y;
        RTVector3 *RollPitchYaw = new RTVector3();

        //convertPlanarToHome(px,py,receivedCommands.latitude, receivedCommands.longitude);

        // Locking the relatives Mutexs :

        pthread_mutex_lock(&flightStateShared.readWriteMutex);
        pthread_mutex_lock(&rawPositionShared.readWriteMutex);
        pthread_mutex_lock(&positionShared.readWriteMutex);

        // Sending the data to the global variables

        imuData.fusionPose.accelToEuler(*RollPitchYaw);

        flightStateShared.roll = RollPitchYaw->x();
        flightStateShared.pitch = RollPitchYaw->y();
        flightStateShared.yaw = RollPitchYaw->z();

        rawPositionShared.altitude = altitude;
        rawPositionShared.longitude = receivedCommands.longitude;
        rawPositionShared.latitude = receivedCommands.latitude;

        positionShared.x = x;
        positionShared.y = y;
        positionShared.z = altitude;

        pthread_mutex_unlock(&flightStateShared.readWriteMutex);
        pthread_mutex_unlock(&rawPositionShared.readWriteMutex);
        pthread_mutex_unlock(&positionShared.readWriteMutex);


        }

    }

 }

 int waitForGPS()
 {
    int waitingGPS = 1;
    int attemps = 0;

    while(waitingGPS)
    {
        pthread_mutex_lock(&receivedCommands.readWriteMutex);

        if(receivedCommands.gpsStatus == FIX) waitingGPS = 0;
        else
        {
            attemps ++;
            if (attemps >= GPS_MAX_ATTEMPS) return 0;
            else sleep(1);
        }

        pthread_mutex_unlock(&receivedCommands.readWriteMutex);
    }
    return 1;

 }


 void makeHome(int bmpAlt)
 {
     printDebug("[i] Setting current position as home");

     pthread_mutex_lock(&homeRawPosition.readWriteMutex);
     pthread_mutex_lock(&receivedCommands.readWriteMutex);

     homeRawPosition.longitude = receivedCommands.longitude;
     homeRawPosition.latitude = receivedCommands.latitude;
     homeRawPosition.altitude = (GROUND_MS5611_TRUST*bmpAlt + GROUND_GPS_TRUST*receivedCommands.altitude) / 100;

     homePosition.latitude = homeRawPosition.latitude;
     homePosition.longitude = homeRawPosition.longitude;
     homePosition.z = homeRawPosition.altitude;

     convertPlanarToHome(&homePosition.x, &homePosition.y, homePosition.latitude, homePosition.longitude);

     pthread_mutex_unlock(&homeRawPosition.readWriteMutex);
     pthread_mutex_unlock(&receivedCommands.readWriteMutex);
 }


 /*double calculateBmpAlt()
 {
        unsigned int pressure, temperature;
        unsigned int up, ut;

        ut = bmp085_ReadUT();
        up = bmp085_ReadUP();

        pressure = bmp085_GetPressure(up);
        temperature = bmp085_GetTemperature(ut);

        // Calculating bmp altitude :
        return 44330*(1-pow(pow((pressure/101325),(1/5255)),1000));
 }
*/




